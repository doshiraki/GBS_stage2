<script>
  /** * lib_DemoCore
   * Client Side Logic for DemoOS
   * * Application Hungarian Prefixes:
   * ms: Milliseconds
   * el: DOM Element
   * obj: Object
   * cnt: Count/Number
   * is: Boolean state
   */

  // Global State
  let msServerDiff = 0; 
  let isInitialized = false;

  // Default Config
  let objConfig = {
    clock1: { name: 'Tokyo', offset: 9 },
    clock2: { name: 'London', offset: 0 }
  };

  /** Initialization */
  (async function init() {
    await syncWithServer();
    renderLoop();
  })();

  /** Sync with Server via RPC */
  async function syncWithServer() {
    const msRequestStart = Date.now();
    
    // Call Server Logic
    const objResponse = await new Promise((resolve, reject)=> google.script.run
                  .withSuccessHandler(resolve)  // 成功したら await 側に値を返す
                  .withFailureHandler(reject)   // 失敗したら catch させる
                  .getInitialData());
    
    const msRequestEnd = Date.now();
    const msLatency = (msRequestEnd - msRequestStart) / 2;
    
    // Calc Diff
    const msServerTimeApprox = objResponse.msServerTime + msLatency;
    msServerDiff = msServerTimeApprox - msRequestEnd;

    // Update Config
    if (objResponse.objSettings) {
      objConfig = objResponse.objSettings;
      updateInputs();
    }
    
    isInitialized = true;
    console.log(`[DemoOS] Synced. Diff: ${msServerDiff}ms`);
  }

  /** UI Updates */
  function updateInputs() {
    document.getElementById('elInputName1').value = objConfig.clock1.name;
    document.getElementById('elInputOffset1').value = objConfig.clock1.offset;
    document.getElementById('elTitle1').innerText = objConfig.clock1.name;

    document.getElementById('elInputName2').value = objConfig.clock2.name;
    document.getElementById('elInputOffset2').value = objConfig.clock2.offset;
    document.getElementById('elTitle2').innerText = objConfig.clock2.name;
  }

  /** Save Settings */
  async function saveSettings() {
    const elBtn = document.getElementById('elSaveBtn');
    elBtn.disabled = true;
    elBtn.innerText = "Saving System...";

    objConfig.clock1.name = document.getElementById('elInputName1').value;
    objConfig.clock1.offset = parseFloat(document.getElementById('elInputOffset1').value);
    objConfig.clock2.name = document.getElementById('elInputName2').value;
    objConfig.clock2.offset = parseFloat(document.getElementById('elInputOffset2').value);

    await await new Promise((resolve, reject)=> google.script.run
                  .withSuccessHandler(resolve)  // 成功したら await 側に値を返す
                  .withFailureHandler(reject)   // 失敗したら catch させる
                  .saveSettings(objConfig));
    
    updateInputs();
    elBtn.disabled = false;
    elBtn.innerText = "Sync & Save System";
  }

  /** Render Loop */
  function renderLoop() {
    if (isInitialized) {
      const msNow = Date.now() + msServerDiff; 
      drawClock(1, msNow, objConfig.clock1.offset);
      drawClock(2, msNow, objConfig.clock2.offset);
    }
    requestAnimationFrame(renderLoop);
  }

  function drawClock(id, msBaseTime, cntOffsetHours) {
    const elCanvas = document.getElementById(`elCanvas${id}`);
    const elDigital = document.getElementById(`elDigital${id}`);
    if (!elCanvas) return; // Guard
    const ctx = elCanvas.getContext('2d');
    const radius = elCanvas.height / 2;

    // Calc Time
    const dateTarget = new Date(msBaseTime + (cntOffsetHours * 3600 * 1000) + (new Date().getTimezoneOffset() * 60000)); 

    // Digital
    elDigital.innerText = formatDate(dateTarget);

    // Analog
    ctx.translate(radius, radius);
    ctx.clearRect(-radius, -radius, elCanvas.width, elCanvas.height); 
    drawFace(ctx, radius);
    drawTime(ctx, radius, dateTarget);
    ctx.translate(-radius, -radius); 
  }

  function drawFace(ctx, radius) {
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.95, 0, 2 * Math.PI);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = radius * 0.05;
    ctx.stroke();
    
    ctx.font = radius * 0.15 + "px arial";
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillStyle = '#2c3e50';
    for(let cntNum = 1; cntNum < 13; cntNum++){
      const radAng = cntNum * Math.PI / 6;
      ctx.rotate(radAng);
      ctx.translate(0, -radius * 0.85);
      ctx.rotate(-radAng);
      ctx.fillText(cntNum.toString(), 0, 0);
      ctx.rotate(radAng);
      ctx.translate(0, radius * 0.85);
      ctx.rotate(-radAng);
    }
  }

  function drawTime(ctx, radius, date) {
    const cntHour = date.getHours();
    const cntMinute = date.getMinutes();
    const cntSecond = date.getSeconds();

    // Hour
    let radHour = (cntHour % 12) * Math.PI / 6 + (cntMinute * Math.PI / (6 * 60));
    drawHand(ctx, radHour, radius * 0.5, radius * 0.07, '#2c3e50');
    
    // Minute
    let radMinute = (cntMinute * Math.PI / 30);
    drawHand(ctx, radMinute, radius * 0.8, radius * 0.05, '#2c3e50');
    
    // Second
    let radSecond = (cntSecond * Math.PI / 30);
    drawHand(ctx, radSecond, radius * 0.9, radius * 0.02, '#e74c3c');
  }

  function drawHand(ctx, radPos, length, width, color) {
    ctx.beginPath();
    ctx.lineWidth = width;
    ctx.lineCap = "round";
    ctx.strokeStyle = color;
    ctx.moveTo(0,0);
    ctx.rotate(radPos);
    ctx.lineTo(0, -length);
    ctx.stroke();
    ctx.rotate(-radPos);
  }

  function formatDate(date) {
    const pad = (num) => num.toString().padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ` +
           `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  }
</script>